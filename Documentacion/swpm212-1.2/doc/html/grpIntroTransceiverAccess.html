<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SWPM AT86RF212: Transceiver Access Primitives</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="main.html">AT86RF212 Programming</a>&nbsp;&raquo&nbsp;<a class="el" href="pgSwpmAT86RF212.html">Software Programming Model</a>&nbsp;&raquo&nbsp;<a class="el" href="grpIntro.html">Introduction</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="grpIntroTransceiverAccess">Transceiver Access Primitives </a></h1>The following section describes the basic radio transceiver access primitives:<p>
<ul>
<li><a class="el" href="grpIntroTransceiverAccess.html#grpIntroRegister">Register Access</a></li><li><a class="el" href="grpIntroTransceiverAccess.html#grpIntroBuffer">Frame Buffer Access</a></li><li><a class="el" href="grpIntroTransceiverAccess.html#grpIntroSRAM">SRAM Access Mode</a></li></ul>
<p>
<hr>
<h2><a class="anchor" name="grpIntroRegister">
Register Access</a></h2>
<h3><a class="anchor" name="parReg">
Registers</a></h3>
The radio transceiver has a set of registers, which are used for configuration, reading status information, and initiating transactions.<p>
All registers in the AT86RF212 are 8 bit wide and they can be accessed with a single SPI command (see <a class="el" href="pgRef.html#refDataSheet">section 4.3</a> <em>(SPI Protocol)</em> of the AT86RF212 datasheet). An overview of all registers can be found in <a class="el" href="pgRef.html#refDataSheet">chapter 12</a> <em>(Register Reference)</em> of the AT86RF212 datasheet.<p>
The functions <a class="el" href="group__apiHalFuncBasic.html#gd31a9a2f63e52d485d975d59f7c1d5f4" title="Read the value from a register.">trx_reg_read()</a> and <a class="el" href="group__apiHalFuncBasic.html#g63cd512542173c0a69f2ead0890defed" title="Write a value to a register.">trx_reg_write()</a> implement the SPI packet structure for reading and writing the radio transceiver registers.<p>
Additionaly, the <a class="el" href="group__apiHalPHY212Reg.html">RG_&lt;XYZ&gt;</a> macros contain the addresses of all registers.<p>
<div align="center">
<img src="6-4_Register_Access_Mode-Read_Access.png" alt="6-4_Register_Access_Mode-Read_Access.png">
<p><strong>SPI packet structure for trx_reg_read()</strong></p></div>
  <div align="center">
<img src="6-5_Register_Access_Mode-Write_Access.png" alt="6-5_Register_Access_Mode-Write_Access.png">
<p><strong>SPI packet structure for trx_reg_write()</strong></p></div>
  <h3><a class="anchor" name="pgMultiByte">
Handling of Multibyte Variables</a></h3>
The following example shows the notation, which is used to describe, how multibyte variables are splitted into byte variables, which are used in the sequences for the Extended Operating Mode configuration.<p>
<pre>
      uint64_t var;
      uint8_t var_7_0   = var &amp; 0xff          // bit 7:0
      uint8_t var_15_8  = (var &gt;&gt; 8) &amp; 0xff   // bit 15:8
      uint8_t var_23_16 = (var &gt;&gt; 16) &amp; 0xff  // bit 23:16
      uint8_t var_31_24 = (var &gt;&gt; 24) &amp; 0xff  // bit 31:24
      uint8_t var_39_32 = (var &gt;&gt; 32) &amp; 0xff  // bit 39:32
      uint8_t var_47_40 = (var &gt;&gt; 40) &amp; 0xff  // bit 47:40
      uint8_t var_55_48 = (var &gt;&gt; 48) &amp; 0xff  // bit 55:48
      uint8_t var_63_56 = (var &gt;&gt; 56) &amp; 0xff  // bit 63:56
   </pre><h3><a class="anchor" name="parSReg">
Sub Registers</a></h3>
A sub register is a single bit or a group of adjacent bits within an 8 bit register. It represents a logical value in the radio transceiver, e.g. a power level, a channel number or an interrupt flag. Sub registers are accessed with the functions <a class="el" href="group__apiHalFuncBasic.html#ge7ea3d090b5d26b73a5c62e2e61e0231" title="Read a value from a subregister.">trx_bit_read()</a> and <a class="el" href="group__apiHalFuncBasic.html#g4a22a30602ea72effde4450ce80a6480" title="Write a value to a subregister.">trx_bit_write()</a>, which perform 8 bit register accesses and do the multiplexing and masking. The <a class="el" href="group__apiHalPHY212Sreg.html">SR_&lt;XYZ&gt;</a> macros contain the offset values, masks and shift values for accessing sub registers in the radio transceiver.<p>
For some of the sub registers, there exist predefined <a class="el" href="group__apiHalPHY212Const.html">constants</a> which assign symbolic names to numeric values (e.g. <a class="el" href="group__apiHalPHY212Const.html#gd9aff3d987888b9d1bcb9fc12d2c996e">TRX_OFF</a>, <a class="el" href="group__apiHalPHY212Const.html#g77a32ac338596fe95ea09d7603d7c295">PLL_ON</a>, <a class="el" href="group__apiHalPHY212Const.html#g359db88bcffa6b39bdb64ec00ec3a1ae">RX_ON</a> and <a class="el" href="group__apiHalPHY212Const.html#g44e89d523436fcbbf2c56e4fb335d509">SLEEP</a> as state names for the sub register <a class="el" href="group__apiHalPHY212Sreg.html#gbb9dcc6f85b1154d76645b5de64d4835">SR_TRX_STATUS</a>).<h3><a class="anchor" name="secE1">
Example 1 for sub register SR_TRX_STATUS</a></h3>
This example defines the five bit sub register <a class="el" href="group__apiHalPHY212Sreg.html#gbb9dcc6f85b1154d76645b5de64d4835">SR_TRX_STATUS</a>, which is located in the register <a class="el" href="group__apiHalPHY212Reg.html#g3ef224e06f9b07c132b98daeb089f9ae">RG_TRX_STATUS</a>. <pre></pre><p>
<pre>   #define SR_TRX_STATUS   0x01, 0x1f, 0</pre><p>
<pre>       -------------------------------
      | Register 0x01:  RG_TRX_STATUS |
       --- --- --- --- --- --- --- ---
      |   |   |   | v   v   v   v   v |
       --- --- --- --- --- --- --- ---
        7   6   5   4   3   2   1   0
                  [===================]---&gt; SR_TRX_STATUS</pre><p>
<pre>                   offset = 0x01
                   mask   = 0x1f
                   shift  =    0
  </pre><h3><a class="anchor" name="secE2">
Example 2 for sub register SR_TX_AUTO_CRC_ON</a></h3>
This example defines the single bit sub register <a class="el" href="group__apiHalPHY212Sreg.html#g53420a51ab0ad2e5b108d5cbbdf6f3b6">SR_TX_AUTO_CRC_ON</a>, which is located in the register <a class="el" href="group__apiHalPHY212Reg.html#g1d1e66a62e8f748c93a2143ebc262d15">RG_TRX_CTRL_1</a>.<p>
<pre>
    #define SR_TX_AUTO_CRC_ON   0x04, 0x20, 5</pre><p>
<pre>       -------------------------------
      | Register 0x04:  RG_TRX_CTRL_1 |
       --- --- --- --- --- --- --- ---
      |   |   | v |   |   |   |   |   |
       --- --- --- --- --- --- --- ---
        7   6   5   4   3   2   1   0
      --------[===]-----------------------&gt; SR_TX_AUTO_CRC_ON</pre><p>
<pre>                   offset = 0x04
                   mask   = 0x20
                   shift  =    5
   </pre><p>
<hr>
<h2><a class="anchor" name="grpIntroBuffer">
Frame Buffer Access</a></h2>
<h3><a class="anchor" name="secBAccess">
Frame Buffer Access Mode</a></h3>
The 128-byte frame buffer can store a single IEEE 802.15.4 compliant PHY packet, consisting of PHY Header (PHR) and PHY Payload (PSDU: PHY service data unit) at a time, see also <a class="el" href="pgRef.html#refDataSheet">section 4.3.2</a> <em>(Frame Buffer Access Mode)</em> of the AT86RF212 datasheet.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The synchronization header (SHR) of the PHY packet is generated/detected automatically from the radio transceiver in TX or RX mode and is not stored in the frame buffer.</dd></dl>
If a frame has to be stored in the radio transceiver for transmission, the function <a class="el" href="group__apiHalFuncBasic.html#g9191fea0f277cb46af5ad28b67a6356d" title="Write a frame to the radio transceiver.">trx_frame_write()</a> is used. A received frame can be read from the radio transceiver by the MCU with the function <a class="el" href="group__apiHalFuncBasic.html#g88ff4f45a0c4c7435d686150cc7fb4c2" title="Read a frame from the radio transceiver.">trx_frame_read()</a>.<p>
<div align="center">
<img src="SPI_PacketStructure_FrameRead.png" alt="SPI_PacketStructure_FrameRead.png">
<p><strong>SPI packet structure for trx_frame_read()</strong></p></div>
  <div align="center">
<img src="SPI_PacketStructure_FrameWrite.png" alt="SPI_PacketStructure_FrameWrite.png">
<p><strong>SPI packet structure for trx_frame_write()</strong></p></div>
  <h3><a class="anchor" name="secBEmpty">
Frame Buffer Read with Empty Indicator</a></h3>
If a frame has to be read from the radio transceiver while the reception process is in progress (e.g. if the frame upload has to start with the <a class="el" href="group__apiHalPHY212Const.html#gab5ff5ca963c7556f4f1e0e37f045604">TRX_IRQ_RX_START</a> in order to meet IEEE 802.15.4 ACK timing), the "empty indicator" feature of the radio transceiver can be used. It is described in section <a class="el" href="grpBEmpty.html">Frame Buffer Empty Indicator</a>. The empty indication is signaled via the <a class="el" href="grpIntroMCU.html#wirePinIrq">TRX_PIN_IRQ</a> line, which is asserted, if the frame buffer gets empty. The function <a class="el" href="group__apiHalFuncBasic.html#gee1a17975e51ef9df001ff17be1cf6f5" title="Read frame in buffer level mode.">trx_frame_read_blm()</a> implements this feature.<p>
<hr>
<h2><a class="anchor" name="grpIntroSRAM">
SRAM Access Mode</a></h2>
<h3><a class="anchor" name="secSRAMOvr">
Memory Map of the SRAM</a></h3>
The following graphic illustrates the logical organization of the SRAM:<p>
<pre>
      +------ ------ ~~~~~~ ------+------ ------+------ ------ ~~~~~~ ------ ------+
      | 0x00 | 0x01 |      | 0x7F | 0x80 | 0x81 | 0x82 | 0x83 |      | 0x93 | 0x94 |
      +------ ------ ~~~~~~ ------+------ ------+------ ------ ~~~~~~ ------ ------+
      | Frame Buffer (1)          | reserved    | AES Block (1,2)                  |
      +------ ------ ~~~~~~ ------+------ ------+------ ------ ~~~~~~ ------ ------+
 </pre><p>
The different blocks are accessed with different SPI packet structures.<ul>
<li>(1) accessable with the functions <a class="el" href="group__apiHalFuncBasic.html#g9cefef2438958ba66d3696eb01aa8470" title="Read data from SRAM.">trx_sram_read()</a>, <a class="el" href="group__apiHalFuncBasic.html#gfd63982d9050e370d586937c6f8f6cb6" title="Write data to SRAM.">trx_sram_write()</a>.</li><li>(2) accessable with the functions <a class="el" href="group__apiHalFuncBasic.html#g53c5a480cc77c15e61d5b6582070d944" title="Read data from AES block.">trx_aes_read()</a>, <a class="el" href="group__apiHalFuncBasic.html#g80132a40aa746cff703fdfc242360581" title="Write data to the AES block.">trx_aes_write()</a>, <a class="el" href="group__apiHalFuncBasic.html#g6da4dc8ef15aea804539e3c626644cd7" title="Write and read data from AES block simultaneously.">trx_aes_wrrd()</a>.</li></ul>
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Although the frame buffer and the AES block have consecutive SRAM addresses, they cannot be read in one block.</dd></dl>
<h3><a class="anchor" name="secSRAM">
SRAM Access</a></h3>
The SRAM is subdivided into a radio transceiver section [0x00...0x7F] and an AES section [0x82...0x94]. The former can be accessed using <a class="el" href="group__apiHalFuncBasic.html#g9cefef2438958ba66d3696eb01aa8470" title="Read data from SRAM.">trx_sram_read()</a> and <a class="el" href="group__apiHalFuncBasic.html#gfd63982d9050e370d586937c6f8f6cb6" title="Write data to SRAM.">trx_sram_write()</a>, whereas the latter can be accessed using <a class="el" href="group__apiHalFuncBasic.html#g80132a40aa746cff703fdfc242360581" title="Write data to the AES block.">trx_aes_write()</a>, <a class="el" href="group__apiHalFuncBasic.html#g53c5a480cc77c15e61d5b6582070d944" title="Read data from AES block.">trx_aes_read()</a> and <a class="el" href="group__apiHalFuncBasic.html#g6da4dc8ef15aea804539e3c626644cd7" title="Write and read data from AES block simultaneously.">trx_aes_wrrd()</a>. However, the AES-functions trx_aes_*() internally use functions trx_sram_*(). The AES functions are provided in this document for a simplified access to the AES block.<p>
<div align="center">
<img src="SPI_PacketStructure_SRAMRead.png" alt="SPI_PacketStructure_SRAMRead.png">
<p><strong>SPI packet structure for trx_sram_read()</strong></p></div>
  <div align="center">
<img src="SPI_PacketStructure_SRAMWrite.png" alt="SPI_PacketStructure_SRAMWrite.png">
<p><strong>SPI packet structure for trx_sram_write()</strong></p></div>
  <h3><a class="anchor" name="secFast">
AES Block Access and Fast SRAM Access</a></h3>
The AES block has a special SPI packet structure, which is shown below. In order to use the AES block, the following functions can be used:<ul>
<li><a class="el" href="group__apiHalFuncBasic.html#g80132a40aa746cff703fdfc242360581" title="Write data to the AES block.">trx_aes_write()</a> for AES access 0</li><li><a class="el" href="group__apiHalFuncBasic.html#g6da4dc8ef15aea804539e3c626644cd7" title="Write and read data from AES block simultaneously.">trx_aes_wrrd()</a> for AES access [1...n]</li><li><a class="el" href="group__apiHalFuncBasic.html#g53c5a480cc77c15e61d5b6582070d944" title="Read data from AES block.">trx_aes_read()</a> for AES access n+1</li></ul>
<p>
The fast SRAM access, described in function <a class="el" href="group__apiHalFuncBasic.html#g6da4dc8ef15aea804539e3c626644cd7" title="Write and read data from AES block simultaneously.">trx_aes_wrrd()</a>, can only be used for the AES block. This mode allows simultaneously writing new data and reading data from previously processed data within the same SPI transfer.<p>
<div align="center">
<img src="SPI_PacketStructure_FastSRAMAccessMode.png" alt="SPI_PacketStructure_FastSRAMAccessMode.png">
<p><strong>SPI packet structure for trx_aes_wrrd()</strong></p></div>
  <dl class="note" compact><dt><b>Note:</b></dt><dd><sup>[1]</sup> Byte 19 is the mirrored version of register AES_CTRL on SRAM address 0x94, see register description AES_CTRL_MIRROR for details. </dd></dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Aug 17 13:34:58 2009 for SWPM AT86RF212 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
